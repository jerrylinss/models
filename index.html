<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>兔子模型</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "https://esm.sh/three@0.160.0";
      import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";


      const modelUrl = 'Bunny.glb';
      // 场景
      const scene = new THREE.Scene();

      // 相机
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 10);

      // 渲染器
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 光照
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
      hemiLight.position.set(0, 20, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(5, 10, 7.5);
      scene.add(dirLight);

      // 控制器
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      let mixer;
      let actions = [];
      let currentActionIndex = 0;
      // 加载兔子模型
      const loader = new GLTFLoader();
      loader.load(
        modelUrl,
        (gltf) => {
          console.log(gltf);
          
          const bunny = gltf.scene;
          // bunny.scale.set(0.05, 0.05, 0.05); // 缩放
          bunny.position.set(0, -1, 0);
          scene.add(bunny);
          if (gltf.animations && gltf.animations.length) {
            mixer = new THREE.AnimationMixer(bunny);

            // 创建每个动作
            actions = gltf.animations.map((clip) => mixer.clipAction(clip));

            // 播放第一个动作
            currentActionIndex = 0
            actions[currentActionIndex].play();

            // 监听动作完成事件，切换到下一个动作
            mixer.addEventListener('finished', () => {
              // 停止当前动作
              actions[currentActionIndex].stop();

              // currentActionIndex = (currentActionIndex + 1) % actions.length;
              setTimeout(() => {
                actions[currentActionIndex].play();
                // 切换到下一个动作
              }, 100);
            });

            // 确保每个动作都是一次播放（loop: THREE.LoopOnce）
            actions.forEach((action) => {
              action.setLoop(THREE.LoopOnce);
            });
          }
        },
        (xhr) => {
          console.log(`加载进度: ${((xhr.loaded / xhr.total) * 100).toFixed(2)}%`);
        },
        (error) => {
          console.error("加载模型失败:", error);
        }
      );

      // 自适应窗口
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      const clock = new THREE.Clock();
      // 动画循环
      function animate() {
        const delta = clock.getDelta();
        if (mixer) mixer.update(delta);
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
    </script>
  </body>
</html>
